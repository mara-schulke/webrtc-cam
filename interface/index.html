<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <style>
            .room {
                display: flex;
                flex-direction: column;
                width: 1280px;
                height: 720px;
            }

            .room video {
                /*height: 50%;*/
                background-color: gray;
            }

            .room video:first-child {
                border-bottom: 1px solid lightgray;
            }
        </style>
    </head>
    <body>
    <div id="app"></div></br>
    <div class="room">
        <video id="video" autoplay controls playsinline>Your browser does not support video</video>
    </div>
    <pre id="log"></pre>
        <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>
        <script type="module">
            const device = '0000000000000000000000000000000000000000000000000000000000000000';
            const host = window.location.hostname === 'localhost' ? 'localhost' : `${window.location.hostname}:9000`;
            const websocket = new WebSocket(`ws://${host}/${device}/stream?peer=client`);

            const log = document.getElementById("log");
            const app = document.getElementById("app");

            const send = msg => {
                const mapped = _.mapKeys(msg, (val, key) => _.snakeCase(key));
                const serialized = JSON.stringify(mapped);
                websocket.send(serialized);
                log.append(`Sent ${serialized}\n`);
            }

            const state = {
                error: null,

                stream: {
                    preview: null,
                    video: document.getElementById("video"),
                    localMedia: null,
                    peerConnection: null,
                },

                log: [],
            };

            websocket.onopen = () => startCall(state);

            websocket.onmessage = ({ data }) => {
                log.append(`Received ${data}\n`);
                let parsed = _.mapKeys(JSON.parse(data), (val, key) => _.camelCase(key));
                onSignal(parsed);
                render(state);
            }

            websocket.onclose = () => {
                state.error = 'Lost the connection';
                render(state);
                logStateUpdate();
            };

            const logStateUpdate = () => {
                log.append(`State ${JSON.stringify(state)}\n`);
                if (state.error) {
                    log.append(`Error (${state.error})\n`);
                }
            }

            let render = state => {
                app.innerHTML = '';

                if (state.error) {
                    app.innerHTML += `
                        <strong>Error: ${state.error}</strong></br></br>
                        <button onclick="window.location.reload()">Retry</button>
                    `;
                    return;
                }
            };

            const startCall = state => {
                console.log('Creating RTCPeerConnection');

                state.stream.peerConnection = new RTCPeerConnection({
                    iceServers: [
                        {urls: "stun:stun.l.google.com:19302"},
                        {
                            urls: "turn:openrelay.metered.ca:80",
                            username: "openrelayproject",
                            credential: "openrelayproject",
                        },
                        {
                            urls: "turn:openrelay.metered.ca:443",
                            username: "openrelayproject",
                            credential: "openrelayproject",
                        },
                        {
                            urls: "turn:openrelay.metered.ca:443?transport=tcp",
                            username: "openrelayproject",
                            credential: "openrelayproject",
                        },
                    ],
                });

                state.stream.localMedia = getLocalMedia().then(stream => {
                    console.log('Adding local stream to call', stream, state.stream.peerConnection);
                    stream.getTracks().forEach(track => state.stream.peerConnection.addTrack(track, stream));
                    return stream;
                }).catch(e => state.error = e);

                state.stream.peerConnection.ondatachannel = console.warn;
                state.stream.peerConnection.oniceconnectionstatechange = ev => console.warn("ice connection state change", ev.currentTarget.iceConnectionState);
                state.stream.peerConnection.onicegatheringstatechange = ev => console.warn("ice gathering state change", ev.currentTarget.iceGatheringState);
                state.stream.peerConnection.onnegotiationneeded = () => sendOffer(state);
                state.stream.peerConnection.onsignalingstatechange = ev => console.warn("signaling state change", ev.currentTarget.signalingState);

                state.stream.peerConnection.ontrack = ev => {
                    console.log("incoming stream", ev);
                    console.log(ev.streams[0].getTracks());
                    
                    const video = state.stream.video;

                    if (video.srcObject !== ev.streams[0]) {
                        console.log("storing incoming stream", ev);
                        video.srcObject = ev.streams[0]
                        console.log(video)
                    }
                };

                state.stream.peerConnection.onicecandidate = event => {
                    if (event.candidate === null || event.candidate === "") {
                        console.log("ICE Candidate was null, done");
                        return;
                    }

                    const { candidate, sdpMLineIndex } = event.candidate;

                    send({ candidate, sdpMlineIndex: sdpMLineIndex, sdpMid: "", usernameFragment: "" })
                };
            };

            const stopCall = state => {
                console.log(state.stream.video)
                state.stream.video.srcObject?.getVideoTracks().forEach(track => {
                    track.stop();
                    state.stream.video.srcObject.removeTrack(track);
                });
                state.stream.video.pause();
                state.stream.video.src = "";
                state.stream.video.load();

                state.stream.peerConnection.close();
                state.stream = {
                    ...state.stream,
                    localMedia: null,
                    peerConnection: null,
                };
            };

            const sendOffer = state => {
                state.stream.peerConnection.createOffer({ offerToReceiveVideo: true })
                    .then(desc => { console.log("got local description: " + JSON.stringify(desc)); return desc})
                    .then(desc => state.stream.peerConnection.setLocalDescription(desc))
                    .then(() => send(state.stream.peerConnection.localDescription))
            }

            const onSignal = signal => {
                if (signal.event == "start" && state.stream.peerConnection.connectionState != "new") {
                    window.location.reload()
                }

                if (signal.candidate && signal.sdpMlineIndex != null) {
                    console.log(signal);
                    const candidate = new RTCIceCandidate({
                        candidate: signal.candidate,
                        sdpMLineIndex: signal.sdpMlineIndex,
                        sdpMid: signal.sdpMid,
                        usernameFragment: signal.usernameFragment
                    });
                    console.log(candidate);
                    state.stream.peerConnection.addIceCandidate(candidate).catch(e => state.error = e);
                    return;
                }

                if (signal.type && signal.sdp) {
                    console.log("received sdp signal", signal)
                    state.stream.peerConnection.setRemoteDescription(signal)
                        .then(() => {
                            if (signal.type === "answer") return;

                            state.stream.peerConnection.createAnswer()
                                .then(answer => state.stream.peerConnection.setLocalDescription(answer))
                                .then(() => {
                                    const { sdp, type } = state.stream.peerConnection.localDescription;
                                    send({ sdp, type })
                                })
                                .catch(e => state.error = e);
                        });

                    return;
                }
            }

            const getLocalMedia = () => {
                try {
                    return navigator.mediaDevices.getUserMedia({ audio: true });
                } catch (e) {
                    console.error("unable to stream audio to device");
                    return Promise.reject()
                }
            }
        </script>
    </body>
</html>
